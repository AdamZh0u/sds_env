# Programming Environment

Over the years, we have experimented with a range of approaches to setting you up with a programming environment, and we have come to the conclusion that **Docker** is the most robust way to ensure a consistent experience. This guarantees that all students end up with the same versions of each library, that difficult-to-diagnose hardware/OS issues are minimised, and that running/recovery is the most straightforward.

A very small number of students are **unable to run Docker** on older machines running Windows 10 Home, in which case **Anaconda Python** can be used with the [configuration file](https://github.com/jreades/sds_env/#using-anaconda-python) that we provide. However, if your machine runs Docker then you **must** use Docker: this isolates the programming environment from your computer, ensuring that nothing is clobbered by accident, and guaranteeing that you are working with the same version of every Python library as the rest of the class (and the versions for which the practicals are tested). 

Anaconda is only supported as a last resort.

## Docker

There are many options for how Docker sets up and runs 'virtual machines' (known as 'images') on your local system (i.e. the computer on which you're reading this now!). The `jreades/sds:2022` image contains (we hope) all of the tools that you'll need to get through the majority of our programme when you are working in Python. There are so many options that we actually [created a script](https://github.com/jreades/sds_env/raw/master/docker/docker.sh) to do most of it for you; however, this needs to be paired with a [configuration file](https://github.com/jreades/sds_env/raw/master/docker/config.sh) that is in the same folder as the `docker.sh` script so it's an extra step to getting up and running.

The *bare minimum* for getting up and running (once you've installed Docker) is:

```bash
DOCKER_NM="{{< var env.name >}}"
DOCKER_IMG="{{< var env.image >}}"
JUPYTER_PORT=8888
QUARTO_PORT=4200
WORK_DIR="${PWD}"
JUPYTER_PWD=""
docker run --rm -d --name $DOCKER_NM -p "$JUPYTER_PORT":8888 -p "$QUARTO_PORT":4200 -v "$WORK_DIR":/home/jovyan/work $DOCKER_IMG start.sh jupyter lab --LabApp.password=$JUPYTER_PWD --ServerApp.password=$JUPYTER_PWD --NotebookApp.token=$JUPYTER_PWD
```

::: {.callout-warning}
## Known Windows Issues

On Windows, if you cannot see any of the files on your _main_ system when you start up Docker with the SDS image, then please try replacing this part of the Docker command (see details below):

`-v "$WORK_DIR":/home/jovyan/work`

with:

`--mount type=bind,source="$(pwd)",target=/home/jovyan/work`

This should enable you to see any existing files that you have, while also allowing you to save any files that you create.
:::

As well...

::: {.callout-warning}
## Known Mac Issues 

On Mac, if you are using one of the new M1 or M2 chips on your _main_ system then you need to tell Docker to emulate the older Intel chipset (which is all I have access to!) by changing this part of the Docker `run` command (see details below):

`--name sds -p 8888:8888`

to:

`--name sds --platform linux/amd64 -p 8888:8888`

:::

## VSCode

By default, Docker+JupyterLab enables you to interact with code via a web browser, and we've built in many useful tools for a streamlined, effective in-browser experience. However, if you're more familiar with IDEs then VSCode offers an interesting alternative: after installing VSCode, you'll also need to install the following extensions:

1. The [Remote - Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) extension from Microsoft, which will allow you to use a Docker container as a virtual environment from VSCode.
2. The [Docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker) extension from Microsoft, which allows you to interact with images/containers from within VSCode.
3. The [Jupyter](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter) exension, which will allow you to execute Jupyter Notebooks directly within VSCode.
4. The [Jupyter Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers) extension which adds support for media outputs, especially interactive ones.
5. The "Jupyter Keymap" exension which provides the same keymaps in VSCode that exist in JupyterLab.
6. The [Pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance) extension which works as a language server (will do code highlighting, syntax checking, etc.) for Python.
7. The [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) extension which provides rich support for Python >= 3.7.
8. The [Gremlins Tracker](https://marketplace.visualstudio.com/items?itemName=nhoizey.gremlins) extension which highlights non-printing characters that can make code fail to execute properly.

You can supplement these with the Markdown linting extension and a range of other tools. 

Once this is all installed, you start up your Docker container (as above) and then tell VSCode to connect to that container using the instructions provided. Once you've done this _once_ it should be fairly straightforward on subsequent runs. At that point you can browse to the notebooks (which are usually being mounted from your own machine) and run them as if you were doing all of this within the Docker container. It's kind of mind-melting but pretty cool.

## Anaconda Python

Again, we *only* support Anaconda Python as a fallback for students who would otherwise be unable to complete the module because their computer does not support Docker. You are always free to install Anaconda Python and to use our YAML configuration script to install the SDS environment, but you should do this in your own time: in previous years students have encountered difficult-to-diagnose bugs in their code (and lost marks in the Assessments!) because they had installed an older or more recent version of a Python library than the one configured and tested in the SDS environment.

We believe that the replication advantages of *virtualisation* outweigh the disbenefits in terms of *performance*. It also means that you will spend less time installing libraries and more time running code, which is where your attention should really be when you are familiarising yourself with the *foundations* of data science. Eventually you will, of course, want to install and manage your own programming environment (possibly even by building and sharing Docker images!) but this can be left for later when you have developed an appreciation of how and when virtualisation is (or is not) an appropriate solution to your needs.
